/*Description: PoC , Dynamic API resolving using function hash */
// include ncessary header files 
#include <stdio.h> 
#include <stdlib.h>
#include <Windows.h>

DWORD hashFromFunctionName(char* funcName){
    size_t strSize = strlen(funcName); // get the length of the funcName
    DWORD hash = 0x40; // hash value 

    for (size_t i = 0 ; i < strSize ; i++ ){
        hash =  ( (hash * 0x9987654 + funcName[i]) & 0xffffff ) + hash; // the math 
    }

    return hash;
}


PDWORD resolveExportFromHash(DWORD hash,const wchar_t* const library){
    /*load dll into memory*/
    HMODULE hMod;
     hMod = LoadLibraryW(library);
    if (hMod == INVALID_HANDLE_VALUE){
        printf("Couldn't load:%S\n",library);
        exit(1);
    }

    PIMAGE_DOS_HEADER dosHdr = NULL;
    PIMAGE_NT_HEADERS ntHdr = NULL;
    PIMAGE_DATA_DIRECTORY dataDir = NULL;
    PIMAGE_EXPORT_DIRECTORY exportDirectory = NULL;
    PDWORD addressOfNames = NULL;
    PDWORD addressOfFunctions = NULL;
    PWORD addressOfNameOrdinals = NULL;
    DWORD exportHash = 0;
    
    /*get ptr to IMAGE_DOS_HEADER*/
    dosHdr = (PIMAGE_DOS_HEADER)hMod; // ptr to IMAGE_DOS_HEADER 
    /*get ptr to IMAGE_NT_HEADERS*/
    ntHdr = (PIMAGE_NT_HEADERS)((DWORD_PTR)hMod + dosHdr->e_lfanew); // ptr to PE headers (NT headers)

   /* get ptr to DataDirectory[]*/

   dataDir = (PIMAGE_DATA_DIRECTORY)((DWORD_PTR)hMod + ntHdr->OptionalHeader.DataDirectory);

   /*get ptr to IMAGE_EXPORT_DIRECTORY*/

   exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)hMod + ntHdr->OptionalHeader.DataDirectory[0].VirtualAddress);
   /*get base of AddressOfNames , AddressOfFunctions , AddressOfNameOrdinals */
   addressOfNames = (PDWORD)((DWORD_PTR)hMod + exportDirectory->AddressOfNames);
   addressOfFunctions = (PDWORD)((DWORD_PTR)hMod + exportDirectory->AddressOfFunctions);
   addressOfNameOrdinals = (WORD*)((DWORD_PTR)hMod + exportDirectory->AddressOfNameOrdinals);
   
    /*parse AddressOfNames array , hash over export function names*/ 

   for (size_t i = 0 ; i < exportDirectory->AddressOfNames;i++){
    DWORD functionNameRVA = addressOfNames[i];
    DWORD_PTR functionNameVA = ((DWORD_PTR)hMod + (DWORD_PTR)functionNameRVA);
    /* get the hash of the export func name*/
    exportHash = hashFromFunctionName((char*)functionNameVA);
    /* compare the given hash with export func name hash */
    if (hash == exportHash) {
        if (exportDirectory->Base){
        /* get (hint + Base) = ordinal */ 
        WORD functionNameOrdinal = addressOfNameOrdinals[i] + (WORD)exportDirectory->Base; 
        /* get the func RVA* using ordinal value */
        DWORD functionAddressRVA = addressOfFunctions[functionNameOrdinal-(WORD)exportDirectory->Base]; 
        PDWORD funcionAddressVA = (PDWORD)((DWORD_PTR)hMod + (DWORD_PTR)functionAddressRVA);
        return funcionAddressVA;
    }
    
    }

   }

}

int wmain(int argc , wchar_t** argv ){
  
    int (*function)(HWND ,LPCSTR , LPCSTR ,UINT);
    DWORD hash;
    PDWORD result;
    LPCSTR evil_msg = "You got busted!";
    LPCSTR title = "Warning";   
    const wchar_t * const  library = L"user32.dll";
    /* hash of the func we wish to resolve */
    hash = 0x71358d3; // MessageBoxA hash
    result =  resolveExportFromHash(hash ,library);
    function = (int (*)(HWND , LPCSTR , LPCSTR , UINT))result;
    
    function(0x0 , evil_msg,title,0x0);
    return 0;
}


